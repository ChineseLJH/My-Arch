# “btw I use Arch”

这是我的第一篇文章，我也只是个彩币，写的不好还请见谅 😢

## 为什么开始尝试 Arch

原先我对于Linux可以说是“浅尝辄止”，使用**Ubuntu**也只是图一时新鲜。真正开始接触Linux还是因为**搭建社团的网站**(现在因为一些原因要重新开始了，所以没法放一个超链接 😭😭😭 )，为了保证本地与服务器环境一致(~~因为当时还不知道docker~~)，我将开发、测试等一切关于网站开发的工作放到了Ubuntu上，随着网站一步步成型，我也逐渐喜欢上Linux的风格(?)。接着就是大数据发力了，给我开始推各种各样的关于Linux发行版的视频，但似乎 **Arch Linux** 是评论区里面最特殊的一个发行版🤔,又碰巧国庆节佳节,我也回了家,没带MCU和SBC,家里正好有一台旧电脑 🤓☝️

## 前期准备

我也是在自己熟悉了一段时间**Ubuntu**的操作之后才开始尝试的 **Arch Linux** ，结合整个的安装过程,我认为是需要有一定的Linux基础的💪，并不是很适合没有尝试过Linux的**纯萌新**来做尝试🤕，所以接下来的教程我会**默认**认为你有一定的基础 👊

### Arch Linux 镜像下载

对于**Windows**系统下如何创建“未分配”空间以及怎么关闭**BitLocker**，怎么关闭**BIOS**中的安全启动(Secure Boot)等比较常规的操作。

[**Arch Linux**](https://archlinux.org/) 这就是Arch Linux的官网,相较于 [**Ubuntu**](https://cn.ubuntu.com/) 的官网，就显得有点凌乱()。[**Download**](https://archlinux.org/download/) 这就是官网的下载网页，我选了全球的geo.mirror.pkgbuild.com的，国内也有很多的镜像可以直接下载，这里就不多赘述。

### Arch Linux 启动盘制作

在启动盘的制作过程中，我选择的是[**Ventoy**](https://www.ventoy.net/cn/index.html)，它一次性可以装**多个镜像** 🤓，并且在平常还能用作普通U盘存放东西，你只需要在他们的官网进行下载，然后解压，接着插上你的U盘，再运行里面的exe文件，但在安装之前，**一定**要先将U盘里的文件、资料转移至本地，然后再进行安装。安装完毕后，你的U盘名字会被改变，你直接将镜像文件放进去就行，但如果你放了**两个及以上**的镜像时，会多出一个很小的分区，这个可以不用管 😎，将你的文件和镜像都放到那个大的分区就行。至此，你的启动盘就**制作完毕**了 🥳🥳🥳

## 开始安装

在这一部分，我会着重来讲 **Arch Linux** 的安装过程以及途中我遇到的错误，在这过程中，b站上的一些视频和各个ai助手帮了我很多忙 😋

### 启动与网络连接

当你成功从U盘启动后，等到出现 **root@archiso ~ #** 后就可以把你U盘**拔**了，因为此时安装程序**完全加载**进内存了。

#### 1.验证启动器

保险起见，先输入 `ls /sys/firmware/efi/efivars`，如果**输出很多**东西，那说明是**UEFI**，这也是我接下来要讲的 😃，但如果没有，那说明是**Legacy BIOS**，虽然和 **UEFI** 有一定出入，但整体区别不大，我的方法可以作一个参考。

#### 2.联网

在安装过程中，需要从网络下载软件包，所以联网这一步必不可少。

+ **有线**：一般直接接上就行。
+ **无线**：我们可以使用`iwctl`工具进行联网。

    ```bash
    # 进入交互式命令行
    iwctl
    # 列出你的无线设备名，例如 wlan0
    device list
    # 扫描网络 (用你的设备名替换 device)
    station device scan
    # 列出扫描到的网络
    station device get-networks
    # 连接到网络 (用你的WiFi名称替换WiFiname)
    station device connect WiFiname
    # 然后是输入密码，完成后推出软件
    exit
    ```

网络连接完成后可以用类似以下的命令来测试网络连接：
```bash
ping bilibili.com
```
看到连续返回类似 `64 bytes from ...` 说明联网成功，按下`Ctrl+C`即可停止`ping`。

#### 3.更新系统时钟

使用以下命令就可以完成系统时钟的更新：
```bash
timedatectl set-ntp true
```

### 磁盘分区与格式化

这是**最关键且最危险**的一步。我们将使用之前在 **Windows** 中创建的“未分配”空间，我们将挂载 **EFI 系统分区 (ESP)** 并创建 **Swap 分区 (交换分区)** 和 **根 (/) 分区** 。

#### 1.确认硬盘名称

在前面就已经提到要在**Windows**下创建“未分配”空间。我们接下来的操作就是建立在**此基础**上的。我们可以用`lsblk`或者`fdisk -l`来看已分区的部分(你在**Windows**下创建的“未分配”空间在这里是看不到的，所以不用慌)，你需要做的就是记住你现在的**EFI 系统分区**，我们接下来会用到它。

#### 2.使用 `cfdisk` 进行分区

使用以下指令进行分区：

```bash
#具体的位置以你之前确认的硬盘名称为主
cfdisk /dev/sda
```

+ **创建 Swap (交换) 分区**
    + 用键盘的 `↑` 和 `↓` ，选中`Free space` 。
    + 用键盘的 `←` 和 `→` ，在**底部菜单**选中`[ New ]` ，然后按下**回车** 。
    + 程序会提示输入 `Partition size:` ，在后面改成你想要的 **Swap分区** 的大小，然后按下**回车** 。
    + 此时一个新分区被创建出来了，确保选中它，然后用用键盘的 `←` 和 `→` ，在**底部菜单**选中`[ Type ]` ，然后按下**回车** 。
    + 在弹出的类型列表中，用键盘的 `↑` 和 `↓` ，选中 `Linux swap` ，然后按下**回车** 。 

+ **创建 Root (根) 分区**
    + 用键盘的 `↑` 和 `↓` ，选中`Free space` 。
    + 用键盘的 `←` 和 `→` ，在**底部菜单**选中`[ New ]` ，然后按下**回车** 。
    + 程序会提示输入 `Partition size:`，这里默认是剩余的**所有空间** ，所以直接按下**回车**就行，当然你也可以自己改动。
    + 这个分区的类型默认就是 `Linux filesystem`，正是我们需要的，不用修改,当然你也可以自行确认。

+ **写入更改并退出**
    +  **检查**屏幕上的分区规划：一个 `Linux swap` 分区，和一个 `Linux filesystem` 分区。
    + **确认无误**后，用 `←` 和 `→`  键选择底部菜单的 `[ Write ]`，按回车。
    + 程序会请求**最终确认** 。输入 `yes` 然后按回车。
    + 最后，选择 `[ Quit ]` 并按回车，退出 `cfdisk` 工具。

至此，分区部分已经完成，分区方案已经正式写入硬盘的分区表中。

#### 3.格式化并启用新分区

分区部分已经结束，现在我们要开始为它们创建文件系统。

**在此之前**，请先运行一次 `lsblk` 命令，确认一下你新建的两个分区的确切名称。根据你的硬盘情况，它们很可能叫 `/dev/sda2` 和 `/dev/sda3` ，或者 `/dev/sda4` 和 `/dev/sda5` 等。下面的指令请务必使用你看到的**正确名称** ！ 我将以 `/dev/sda4 (Swap)` 和 `/dev/sda5 (Root)` **为例**开始操作。

+ **格式化并启用 `Swap` 分区**
    + 用指令 `mkswap /dev/sda4` 进行**格式化** 。
    + 用指令 `swapon /dev/sda4` **激活**改分区。
    
+ **格式化根分区**
    + 用指令 `mkfs.ext4 /dev/sda5` 建立**文件管理系统**，使得分区可以被用来存储目录和文件。

#### 4.挂载分区

**最后一步**，我们将格式化好的分区连接到系统中。

+ **挂载根分区**
    + 用指令 `mount /dev/sda5 /mnt` 将硬盘分区连接到 `/mnt` 。之后所有对 `/mnt` 的写入操作，都是在向你的硬盘写入数据。

+ **挂载 `EFI` 分区**
    + 用指令 `mount /dev/sda1 /mnt/boot/efi` 在未来的根文件系统中创建一个**专门**用来挂载 `EFI` 分区的文件夹。
    + 再用 `mount /dev/sda1 /mnt/boot/efi`  将 **Windows** 和 **Arch** 共用的 `EFI` 分区连接到正确的位置，以便后续安装引导程序。

最后可以在用 `lsblk` 进行检查。

### pacstrap /mnt base linux linux-firmware nano networkmanager 之后是不是arch Linux基本就安装完了，还是说只安装了框架